// schema.prisma — Minimal MVP with Auth.js + Content + Tags + Collections + Embeddings + single note per content

generator client {
  provider = "prisma-client-js"
}
generator zod {
  provider       = "prisma-zod-generator"
  output         = "./src/zod"   // wherever you want them emitted
  relationModel  = true          // optional: generate relation schemas
  // you can also tune: createInputTypes = true, updateInputTypes = true, etc.
}
generator erd {
  // let Prisma spawn the binary directly from this package
  provider = "prisma-erd-generator"
  output   = "./erd/phtos.svg"
  mmdcPath = "./node_modules/.bin"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
  
}


/////////////////////////////
// Auth.js (NextAuth) models
/////////////////////////////

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts Account[]
  sessions Session[]

  // App relations
  contents       Content[]
  tags           Tag[]
  collections    Collection[]
  Event          Event[]
  UserDomainStat UserDomainStat[]
  Theme          Theme[]
  Slate          Slate[]
}

model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String?
  access_token             String?
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String?
  session_state            String?
  refresh_token_expires_in Int?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

/////////////////////////////
// App models (MVP)
/////////////////////////////

model Content {
  id          String   @id @default(cuid())
  userId      String
  url         String
  domain      String?
  title       String?
  description String?
  text        String? // normalized extracted text (optional)
  note        String? // single user note per content
  savedAt     DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  tags           ContentTag[]
  collections    CollectionItem[]
  embeddings     Embedding[]
  ContentFeature ContentFeature[]
  Event          Event[]
  ThemeItem      ThemeItem[]
  SlateItem      SlateItem[]

  @@index([userId, savedAt])
  @@index([domain])
}

/////////////////////////////
// Tags (per-user namespace)
/////////////////////////////

model Tag {
  id        String   @id @default(cuid())
  userId    String
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  contents ContentTag[]

  @@unique([userId, name])
  @@index([userId])
}

model ContentTag {
  contentId String
  tagId     String
  createdAt DateTime @default(now())

  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)
  tag     Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([contentId, tagId])
}

/////////////////////////////
// Collections (folders)
/////////////////////////////

model Collection {
  id        String   @id @default(cuid())
  userId    String
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user  User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  items CollectionItem[]

  @@unique([userId, name])
  @@index([userId])
}

model CollectionItem {
  collectionId String
  contentId    String
  addedAt      DateTime @default(now())
  position     Int?

  collection Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  content    Content    @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@id([collectionId, contentId])
  @@index([contentId])
}

/////////////////////////////
// Embeddings (simple MVP)
/////////////////////////////

model Embedding {
  id         String @id @default(cuid())
  contentId  String
  model      String
  dimensions Int
  chunkIndex Int    @default(0)

  // pgvector column
  vector Unsupported("vector")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@unique([contentId, model, chunkIndex])
  @@index([contentId])
  @@index([model])
}

// --- New enums ---
enum MediaType {
  ARTICLE
  VIDEO
  PDF
  TWEET
  GITHUB
  OTHER
}

enum ReadingTimeBucket {
  // <= 5 min
  SHORT
  // 6–15 min
  MEDIUM
  // 16–30 min
  LONG
  // > 30 min
  XLONG
}

enum EventType {
  OPEN
  DISMISS
  SNOOZE
  IMPRESSION
}

// --- Content features (1:1 with Content) ---
model ContentFeature {
  // Primary key doubles as FK to Content.id (true 1:1)
  contentId      String             @id
  publishAt      DateTime?
  mediaType      MediaType?
  readingTimeSec Int?
  readingBucket  ReadingTimeBucket?
  hasCodeBlocks  Boolean            @default(false)
  hasChecklist   Boolean            @default(false)
  keywords       Json? // e.g., ["llm","python","tutorial"]
  entities       Json? // e.g., [{text:"OpenAI", type:"ORG"}]
  // small -1..+3 heuristic score (source trust, structure)
  qualityHint    Int?
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@index([readingBucket])
  @@index([mediaType])
  @@index([publishAt])
}

// --- Interaction/events (per user/content) ---
model Event {
  id        String    @id @default(cuid())
  userId    String
  contentId String?
  slateId   String? // tie impressions/clicks to a recommendation run
  type      EventType
  device    String? // "mobile" | "desktop" | etc
  context   Json? // freeform (timeOfDay, surface, referrer)
  createdAt DateTime  @default(now())

  // FK is required -> relation must be required (no '?')
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  // Optional FK -> relation can be optional
  content Content? @relation(fields: [contentId], references: [id])

  @@index([userId, type, createdAt])
  @@index([contentId, type])
  @@index([slateId])
}

// --- Per-user domain stats (precomputed) ---
model UserDomainStat {
  userId    String
  domain    String
  saveCount Int      @default(0)
  lastSaved DateTime @default(now())

  // Add explicit relation for cascade hygiene and nicer querying
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, domain])
  @@index([saveCount])
}

// --- Themes (clusters) computed offline ---
model Theme {
  id        String   @id @default(cuid())
  userId    String
  label     String? // short label like "LLM Tutorials"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user  User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  items ThemeItem[]

  @@index([userId])
}

model ThemeItem {
  themeId   String
  contentId String
  // membership strength 0..100
  strength  Int    @default(50)

  theme   Theme   @relation(fields: [themeId], references: [id], onDelete: Cascade)
  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@id([themeId, contentId])
  @@index([contentId])
}

// --- Recommendation slates (what we generated) ---
model Slate {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())
  // freeform metadata (weights version, request context, etc.)
  meta      Json?

  user  User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  items SlateItem[]

  @@index([userId, createdAt])
}

model SlateItem {
  slateId   String
  position  Int
  contentId String
  score     Int
  reasons   Json? // ["never opened", "fresh-but-forgotten"]

  slate   Slate   @relation(fields: [slateId], references: [id], onDelete: Cascade)
  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@id([slateId, position])
  @@index([contentId])
}
